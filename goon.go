/*
 * Copyright (c) 2012 Matt Jibson <matt.jibson@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package goon

import (
	"errors"
	"fmt"
	"net/http"
	"reflect"
	"sync"
	"time"

	"appengine"
	"appengine/datastore"
	"appengine/memcache"
)

var (
	// LogErrors issues appengine.Context.Errorf on any error.
	LogErrors bool = true
)

// Goon holds the app engine context and request memory cache.
type Goon struct {
	context          appengine.Context
	cache            map[string]interface{}
	cacheLock        sync.RWMutex // protect the cache from concurrent goroutines to speed up RPC access
	inTransaction    bool
	toSet            map[string]interface{}
	toDelete         map[string]bool
	MemcacheTimeout  time.Duration
	DatastoreTimeout time.Duration
}

func memkey(k *datastore.Key) string {
	return k.Encode()
}

// NewGoon creates a new Goon object from the given request.
func NewGoon(r *http.Request) *Goon {
	return FromContext(appengine.NewContext(r))
}

// FromContext creates a new Goon object from the given appengine Context.
func FromContext(c appengine.Context) *Goon {
	return &Goon{
		context:          c,
		cache:            make(map[string]interface{}),
		MemcacheTimeout:  time.Millisecond * 3,
		DatastoreTimeout: time.Millisecond * 500,
	}
}

func (g *Goon) error(err error) {
	if LogErrors && err != nil {
		g.context.Errorf("goon: %v", err.Error())
	}
}

func (g *Goon) extractKeys(src interface{}) ([]*datastore.Key, error) {
	v := reflect.Indirect(reflect.ValueOf(src))
	if v.Kind() != reflect.Slice {
		return nil, errors.New("goon: value must be a slice or pointer-to-slice")
	}
	l := v.Len()

	keys := make([]*datastore.Key, l)
	for i := 0; i < l; i++ {
		vi := v.Index(i)
		key, err := g.getStructKey(vi.Interface())
		if err != nil {
			return nil, err
		}
		keys[i] = key
	}
	return keys, nil
}

// Key is the same as KeyError, except nil is returned on error.
func (g *Goon) Key(src interface{}) *datastore.Key {
	if k, err := g.KeyError(src); err == nil {
		return k
	}
	return nil
}

// Key returns the key of src based on its properties.
func (g *Goon) KeyError(src interface{}) (*datastore.Key, error) {
	return g.getStructKey(src)
}

// RunInTransaction runs f in a transaction. It calls f with a transaction
// context tg that f should use for all App Engine operations. Neither cache nor
// memcache are used or set during a transaction.
//
// Otherwise similar to appengine/datastore.RunInTransaction:
// https://developers.google.com/appengine/docs/go/datastore/reference#RunInTransaction
func (g *Goon) RunInTransaction(f func(tg *Goon) error, opts *datastore.TransactionOptions) error {
	var ng *Goon
	err := datastore.RunInTransaction(g.context, func(tc appengine.Context) error {
		ng = &Goon{
			context:       tc,
			inTransaction: true,
			toSet:         make(map[string]interface{}),
			toDelete:      make(map[string]bool),
		}
		return f(ng)
	}, opts)

	if err == nil {
		g.cacheLock.Lock()
		defer g.cacheLock.Unlock()
		for k, v := range ng.toSet {
			g.cache[k] = v
		}

		for k := range ng.toDelete {
			delete(g.cache, k)
		}
	} else {
		g.error(err)
	}

	return err
}

// Put saves the entity src into the datastore based on src's key k. If k
// is an incomplete key, the returned key will be a unique key generated by
// the datastore.
func (g *Goon) Put(src interface{}) (*datastore.Key, error) {
	ks, err := g.PutMulti([]interface{}{src})
	if len(ks) == 1 {
		return ks[0], err
	}
	return nil, err
}

// PutMany is a wrapper around PutMulti.
func (g *Goon) PutMany(srcs ...interface{}) ([]*datastore.Key, error) {
	return g.PutMulti(srcs)
}

const putMultiLimit = 500

// PutMulti is a batch version of Put.
//
// src must satisfy the same conditions as the dst argument to GetMulti.
func (g *Goon) PutMulti(src interface{}) ([]*datastore.Key, error) {
	keys, err := g.extractKeys(src)
	if err != nil {
		return nil, err
	}

	var memkeys []string
	for _, key := range keys {
		if !key.Incomplete() {
			memkeys = append(memkeys, memkey(key))
		}
	}

	// Memcache needs to be updated after the datastore to prevent a common race condition
	defer memcache.DeleteMulti(g.context, memkeys)

	v := reflect.Indirect(reflect.ValueOf(src))
	for i := 0; i <= len(keys)/putMultiLimit; i++ {
		lo := i * putMultiLimit
		hi := (i + 1) * putMultiLimit
		if hi > len(keys) {
			hi = len(keys)
		}
		rkeys, err := datastore.PutMulti(g.context, keys[lo:hi], v.Slice(lo, hi).Interface())
		if err != nil {
			g.error(err)
			return nil, err
		}

		for i, key := range keys[lo:hi] {
			vi := v.Index(lo + i).Interface()
			if key.Incomplete() {
				setStructKey(vi, rkeys[i])
				keys[i] = rkeys[i]
			}
			if g.inTransaction {
				mk := memkey(rkeys[i])
				delete(g.toDelete, mk)
				g.toSet[mk] = vi
			}
		}
	}

	if !g.inTransaction {
		g.putMemoryMulti(src)
	}

	return keys, nil
}

// PutComplete is like Put, but errors if a key is incomplete.
func (g *Goon) PutComplete(src interface{}) (*datastore.Key, error) {
	k, err := g.getStructKey(src)
	if err != nil {
		return nil, err
	}
	if k.Incomplete() {
		err := fmt.Errorf("goon: incomplete key: %v", k)
		g.error(err)
		return nil, err
	}
	return g.Put(src)
}

// PutMultiComplete is like PutMulti, but errors if a key is incomplete.
func (g *Goon) PutMultiComplete(src interface{}) ([]*datastore.Key, error) {
	keys, err := g.extractKeys(src)
	if err != nil {
		return nil, err
	}
	for i, k := range keys {
		if k.Incomplete() {
			err := fmt.Errorf("goon: incomplete key (%dth index): %v", i, k)
			g.error(err)
			return nil, err
		}
	}
	return g.PutMulti(src)
}

func (g *Goon) putMemoryMulti(src interface{}) {
	v := reflect.Indirect(reflect.ValueOf(src))
	for i := 0; i < v.Len(); i++ {
		g.putMemory(v.Index(i).Interface())
	}
}

func (g *Goon) putMemory(src interface{}) {
	key, _ := g.getStructKey(src)
	g.cacheLock.Lock()
	defer g.cacheLock.Unlock()
	g.cache[memkey(key)] = src
}

func (g *Goon) putMemcache(srcs []interface{}) error {
	items := make([]*memcache.Item, len(srcs))

	for i, src := range srcs {
		gob, err := toGob(src)
		if err != nil {
			g.error(err)
			return err
		}
		key, err := g.getStructKey(src)
		if err != nil {
			return err
		}
		items[i] = &memcache.Item{
			Key:   memkey(key),
			Value: gob,
		}
	}
	errc := make(chan error, 1) // need to buffer so as to not leak a goroutine
	go func() {
		errc <- memcache.SetMulti(g.context, items)
	}()
	g.putMemoryMulti(srcs)
	select {
	case err := <-errc:
		g.error(err)
	case <-time.After(g.MemcacheTimeout):
		return nil // memcache timeout
	}
	return nil
}

type DatastoreResult struct {
	Keys   []*datastore.Key
	Values []interface{}
}

// Get loads the entity based on dst's key into dst
// If there is no such entity for the key, Get returns
// datastore.ErrNoSuchEntity.
func (g *Goon) Get(dst interface{}) error {
	set := reflect.ValueOf(dst)
	if set.Kind() != reflect.Ptr {
		return errors.New(fmt.Sprintf("goon: expected pointer to a struct, got %#v", dst))
	}
	dsts := []interface{}{dst}
	if err := g.GetMulti(dsts); err != nil {
		// Look for an embedded error if it's multi
		if me, ok := err.(appengine.MultiError); ok {
			for i, merr := range me {
				if i == 0 {
					return merr
				}
			}
		}
		// Not multi, normal error
		return err
	}
	set.Elem().Set(reflect.ValueOf(dsts[0]).Elem())
	return nil
}

const getMultiLimit = 1000

// GetMulti is a batch version of Get.
//
// dst has similar constraints as datastore.GetMulti.
func (g *Goon) GetMulti(dst interface{}) error {
	keys, err := g.extractKeys(dst)
	if err != nil {
		return err
	}

	if g.inTransaction {
		// todo: support getMultiLimit in transactions
		return datastore.GetMulti(g.context, keys, dst)
	}

	var memkeys []string // a slice of datastore.Key.Encode() that is not in the local cache
	var mixs []int       // a slice of indexes of dst that represent the memkeys

	var dskeys []*datastore.Key // a slice of datastore.Key that should be fetched by the datastore
	var dsdst []interface{}     // a slice of pointers to the destination objects to be filled, index lines up with dskeys
	var dixs []int              // a slice of indexes of dst that represent the dskeys

	v := reflect.Indirect(reflect.ValueOf(dst))
	g.cacheLock.RLock()
	for i, key := range keys {
		m := memkey(key)
		vi := v.Index(i)
		if s, present := g.cache[m]; present {
			vi.Set(reflect.ValueOf(s))
		} else {
			memkeys = append(memkeys, m)
			mixs = append(mixs, i)
			dskeys = append(dskeys, key)
			dsdst = append(dsdst, vi.Interface())
			dixs = append(dixs, i)
		}
	}
	g.cacheLock.RUnlock()

	if len(memkeys) == 0 { // everything was fetched from local cache, return
		return nil
	}

	memcacheChan := make(chan map[string]*memcache.Item, 1) // buffer so that we don't leak a goroutine if the request times out
	datastoreChan := make(chan error, 1)                    // again, buffer so we don't leak go routine
	datastoreStarted := false
	memcacheTimeout := time.After(g.MemcacheTimeout)
	allTimeout := time.After(g.DatastoreTimeout)
	go func() {
		memvalues, err := memcache.GetMulti(g.context, memkeys)
		g.error(err)
		memcacheChan <- memvalues
	}()
	for {
		select {
		case memvalues := <-memcacheChan: // memcache has returned
			//reset the dskeys as memcache succeeded
			var dskeys []*datastore.Key
			var dsdst []interface{}
			var dixs []int
			for i, m := range memkeys {
				d := v.Index(mixs[i]).Interface()
				if s, present := memvalues[m]; present {
					err := fromGob(d, s.Value)
					if err != nil {
						g.error(err)
						return err
					}
					g.putMemory(d) // populate local cache
				} else {
					// memcache miss
					dskeys = append(dskeys, keys[mixs[i]])
					dsdst = append(dsdst, d)
					dixs = append(dixs, mixs[i])
				}
			}

			if len(dskeys) == 0 { // everything was fetched from local and memcache, return
				return nil
			}
			if !datastoreStarted { // datastore request may have already been issued if memcache took too long to respond
				datastoreStarted = true
				go g.startDatastoreGetMulti(datastoreChan, keys, dskeys, dsdst, dixs)
			}
		case err := <-datastoreChan:
			return err // datastore found the rest of the results and populated memcache
		case <-memcacheTimeout: //memcache taking too long, start the datastore request
			if !datastoreStarted { // datastore request may have alredy been started if memcache finished quickly
				datastoreStarted = true
				go g.startDatastoreGetMulti(datastoreChan, keys, dskeys, dsdst, dixs)
			}
		case <-allTimeout:
			return fmt.Errorf("goon: timeout - GetMulti took longer than %s to return", g.DatastoreTimeout)
		}
	}
}
func (g *Goon) startDatastoreGetMulti(datastoreChan chan error, allKeys, dskeys []*datastore.Key, dsdst []interface{}, dixs []int) {
	multiErr := make(appengine.MultiError, len(allKeys))
	var toCache []interface{}
	var ret error
	for i := 0; i <= len(dskeys)/getMultiLimit; i++ {
		lo := i * getMultiLimit
		hi := (i + 1) * getMultiLimit
		if hi > len(dskeys) {
			hi = len(dskeys)
		}
		gmerr := datastore.GetMulti(g.context, dskeys[lo:hi], dsdst[lo:hi])
		if gmerr != nil {
			merr, ok := gmerr.(appengine.MultiError)
			if !ok {
				g.error(gmerr)
				datastoreChan <- gmerr
				return
			}
			for i, idx := range dixs[lo:hi] {
				multiErr[idx] = merr[i]
				if merr[i] == nil {
					toCache = append(toCache, dsdst[lo+i])
				}
			}
			ret = multiErr
		} else {
			toCache = append(toCache, dsdst[lo:hi]...)
		}
	}

	if len(toCache) > 0 {
		if err := g.putMemcache(toCache); err != nil {
			g.error(err)
			datastoreChan <- err
			return
		}
	}

	datastoreChan <- ret
}

// Delete deletes the entity for the given key.
func (g *Goon) Delete(key *datastore.Key) error {
	keys := []*datastore.Key{key}
	return g.DeleteMulti(keys)
}

const deleteMultiLimit = 500

// DeleteMulti is a batch version of Delete.
func (g *Goon) DeleteMulti(keys []*datastore.Key) error {
	memkeys := make([]string, len(keys))

	g.cacheLock.Lock()
	for i, k := range keys {
		mk := memkey(k)
		memkeys[i] = mk

		if g.inTransaction {
			delete(g.toSet, mk)
			g.toDelete[mk] = true
		} else {
			delete(g.cache, mk)
		}
	}
	g.cacheLock.Unlock()

	// Memcache needs to be updated after the datastore to prevent a common race condition
	defer memcache.DeleteMulti(g.context, memkeys)

	for i := 0; i <= len(keys)/deleteMultiLimit; i++ {
		lo := i * deleteMultiLimit
		hi := (i + 1) * deleteMultiLimit
		if hi > len(keys) {
			hi = len(keys)
		}
		if err := datastore.DeleteMulti(g.context, keys[lo:hi]); err != nil {
			return err
		}
	}
	return nil
}

// NotFound returns true if err is an appengine.MultiError and err[idx] is a datastore.ErrNoSuchEntity.
func NotFound(err error, idx int) bool {
	if merr, ok := err.(appengine.MultiError); ok {
		return idx < len(merr) && merr[idx] == datastore.ErrNoSuchEntity
	}
	return false
}
